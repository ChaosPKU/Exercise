/*
任何一个大学生对菲波那契数列(Fibonacci numbers)应该都不会陌生，它是这样定义的：
F(1)=1;
F(2)=2;
F(n)=F(n-1)+F(n-2)(n>=3);
所以，1,2,3,5,8,13……就是菲波那契数列。
在HDOJ上有不少相关的题目，比如1005 Fibonacci again就是曾经的浙江省赛题。
今天，又一个关于Fibonacci的题目出现了，它是一个小游戏，定义如下：
1、  这是一个二人游戏;
2、  一共有3堆石子，数量分别是m, n, p个；
3、  两人轮流走;
4、  每走一步可以选择任意一堆石子，然后取走f个；
5、  f只能是菲波那契数列中的元素（即每次只能取1，2，3，5，8…等数量）；
6、  最先取光所有石子的人为胜者；

假设双方都使用最优策略，请判断先手的人会赢还是后手的人会赢。

输入数据包含多个测试用例，每个测试用例占一行，包含3个整数m,n,p（1<=m,n,p<=1000）。
m=n=p=0则表示输入结束。

如果先手的人能赢，请输出“Fibo”，否则请输出“Nacci”，每个实例的输出占一行。
*/

/*
Nim游戏是组合游戏(Combinatorial Games)的一种，准确来说，属于“Impartial Combinatorial Games”（以下简称ICG）。满足以下条件的游戏是ICG（可能不太严谨）：1、有两名选手；2、两名选手交替对游戏进行移动(move)，每次一步，选手可以在（一般而言）有限的合法移动集合中任选一种进行移动；3、对于游戏的任何一种可能的局面，合法的移动集合只取决于这个局面本身，不取决于轮到哪名选手操作、以前的任何操作、骰子的点数或者其它什么因素； 4、如果轮到某名选手移动，且这个局面的合法的移动集合为空（也就是说此时无法进行移动），则这名选手负。根据这个定义，很多日常的游戏并非ICG。例如象棋就不满足条件3，因为红方只能移动红子，黑方只能移动黑子，合法的移动集合取决于轮到哪名选手操作。
通常的Nim游戏的定义是这样的：有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。
依据游戏的不同状态进行分类：
N状态：先手必胜，即当前进行游戏操作者必胜(NEXT)；P状态，后手必胜，也成上一次操作游戏者必胜(Previous)，亦即先手必败。
由此可以退出一下三条定义：1、无法进行任何操作的局面，也就是终态，为P状态。2、可以移动到P状态的局面是N状态。3、所有移动都导致N状态的是P状态。
依据是否可以操作，可以操作的话是否可以移动到P状态，必定可以将从初始态到终止态的所有路径组成的图铺满。
(Bouton's Theorem)对于一个普通Nim游戏的局面(a1,a2,...,an)，它是P状态(后手必胜)当且仅当a1^a2^...^an=0。
证明需要证明三条结论：1、判断将所有终止态判定为P状态。2、依据此判断将被判为N状态的局面一定能够移动到某个P状态。3、依据此判断被判为P状态的局面无法移动到某个P状态。(能保证充分，所有保证必要)
1、显然。
2、对于某个局面(a1,a2,...,an)，若a1^a2^...^an!=0，一定存在某个合法的移动，将ai改变成ai'后满足 a1^a2^...^ai'^...^an=0。不妨设a1^a2^...^an=k，则一定存在某个ai，它的二进制表示在k的最高位上是1（否则k的最高位那个1是怎么得到的）。这时ai^k<ai一定成立。则我们可以将ai改变成ai'=ai^k，此时 a1^a2^...^ai'^...^an=a1^a2^...^an^k=0。
3、对于某个局面(a1,a2,...,an)，若a1^a2^...^an=0，一定不存在某个合法的移动，将ai改变成ai'后满足 a1^a2^...^ai'^...^an=0。因为异或运算满足消去率，由a1^a2^...^an=a1^a2^...^ai'^...^an可以得到ai=ai'。所以将ai改变成ai'不是一个合法的移动。证毕。
根据这个定理，我们可以在O(n)的时间内判断一个Nim的局面的性质，且如果它是N-position，也可以在O(n)的时间内找到所有的必胜策略。

下面研究一个更为一般的游戏：给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。事实上，这个游戏可以认为是所有Impartial Combinatorial Games的抽象模型。也就是说，任何一个ICG都可以通过把每个局面看成一个顶点，对每个局面和它的子局面连一条有向边来抽象成这个“有向图游戏”。下面我们就在有向无环图的顶点上定义Sprague-Garundy函数。
首先定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。
对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数g如下：g(x)=mex{ g(y) | y是x的后继 }。
SG函数的性质：1、所有的终止状态所对应的顶点，也就是没有出边的顶点，其SG值为0，因为它的后继集合是空集。2、对于一个g(x)!=0的顶点，必定存在一个后继y满足g(y)=0。3、对于一个g(x)=0的顶点x，它的所有后继y都满足 g(y)!=0。
以上性质保证，顶点x所代表的状态是P状态当且仅当g(x)=0。通过计算有向无环图的每个顶点的SG值，就可以对每种局面找到必胜策略。
如果将有向图游戏变复杂一点，比如说，有向图上并不是只有一枚棋子，而是有n枚棋子，每次可以任选一颗进行移动，这时，怎样找到必胜策略呢？
考虑一下顶点的SG值的意义。当g(x)=k时，表明对于任意一个0<=i<k，都存在x的一个后继y满足g(y)=i。也就是说，当某枚棋子的SG值是k时，可以把它变成0、变成1、……、变成k-1，但绝对不能保持k不变。由此可以联想到Nim游戏，Nim 游戏的规则就是：每次选择一堆数量为k的石子，可以把它变成0、变成1、……、变成k-1，但绝对不能保持k不变。这表明，如果将n枚棋子所在的顶点的SG值看作n堆相应数量的石子，那么这个Nim游戏的每个必胜策略都对应于原来这n枚棋子的必胜策略！
对于n个棋子，设它们对应的顶点的SG值分别为(a1,a2,...,an)，再设局面(a1,a2,...,an)时的Nim游戏的一种必胜策略是把ai变成k，那么原游戏的一种必胜策略就是把第i枚棋子移动到一个SG值为k的顶点。所以这两个问题其实是等价的。
由此可以证明这种多棋子的有向图游戏的局面是P状态当且仅当所有棋子所在的位置的SG函数的异或为0。这个证明与之前Bouton's Theorem的证明几乎是完全相同的。
由此可以推广：定义有向图游戏的和(Sum of Graph Games)：设G1、G2、……、Gn是n个有向图游戏，定义游戏G是G1、G2、……、Gn的和(Sum)，游戏G的移动规则是：任选一个子游戏Gi并移动上面的棋子。Sprague-Grundy Theorem就是：g(G)=g(G1)^g(G2)^...^g(Gn)。也就是说，游戏的和的SG函数值是它的所有子游戏的SG函数值的异或。
所以当面对由n个游戏组合成的一个游戏时，只需对于每个游戏找出求它的每个局面的SG值的方法，就可以把这些SG值全部看成Nim的石子堆，然后依照找Nim的必胜策略的方法来找这个游戏的必胜策略了！
解题模型：
   1.把原游戏分解成多个独立的子游戏，则原游戏的SG函数值是它的所有子游戏的SG函数值的异或。
      即sg(G)=sg(G1)^sg(G2)^...^sg(Gn)。
   2.分别考虑没一个子游戏，计算其SG值。
      SG值的计算方法：（重点）
      1.可选步数为1~m的连续整数，直接取模即可，SG(x) = x % (m+1);
      2.可选步数为任意步，SG(x) = x;
      3.可选步数为一系列不连续的数，按部就班计算。DP方法，记录从1-N-1的sg值，对于N，根据可选步数在N的下一步状态集合中进行mex计算。
*/
#include <iostream>  
#include <cstdio>  
#include <cstring>  
using namespace std;  
  
const int N = 1005;  
int f[N];//可以取走的石子个数  
int sg[N];//0~n的SG函数值  
int Hash[N];  
  
void getSG(int n){  
    memset(sg,0,sizeof(sg));  
    for(int i = 1; i <= n; i++){  
        memset(Hash,0,sizeof(Hash));  
        for(int j = 1; f[j] <= i; j++)  
            Hash[sg[i-f[j]]] = 1;  
        for(int j = 0; j <= n; j++){    //求mes{}中未出现的最小的非负整数  
            if(Hash[j] == 0){  
                sg[i] = j;  
                break;  
            }  
        }  
    }  
}  
  
int main(){  
    f[0] = f[1] = 1;  
    for(int i = 2; i <= 16; i++)  
        f[i] = f[i-1]+f[i-2];  
    getSG(1000);  
    int m,n,p;  
    while(scanf("%d%d%d",&m,&n,&p),m+n+p){  
        if(sg[m]^sg[n]^sg[p])  
            puts("Fibo");  
        else  
            puts("Nacci");  
    }  
    return 0;  
} 

/*题目给出了一种计算sg值的DP方法，下面给出DFS的方法模板：
注意 S数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍    
n是集合s的大小 S[i]是定义的特殊取法规则的数组    
int s[110],sg[10010],n;    
int SG_dfs(int x)    
{    
    int i;    
    if(sg[x]!=-1)    
        return sg[x];    
    bool vis[110];    
    memset(vis,0,sizeof(vis));    
    for(i=0;i<n;i++)    
    {    
        if(x>=s[i])    
        {    
            SG_dfs(x-s[i]);    
            vis[sg[x-s[i]]]=1;    
        }    
    }    
    int e;    
    for(i=0;;i++)    
        if(!vis[i])    
        {    
            e=i;    
            break;    
        }    
    return sg[x]=e;    
}   
*/
